---
layout:     post
title:      "KCP:一种高效且可靠的ARQ协议"
subtitle:   "\"KCP - A Fast and Reliable ARQ Protocol\""
date:       2022-07-04 11:00
header-img: "img/google-picture.jpg"
author:     "pancakeliu"
catalog:    true
tags:
    - kcp
    - network
---

### 1. KCP简介

KCP是一个快速可靠协议，能以比 TCP 浪费 10\-20% 的带宽的代价，换取平均延迟降低 30%\-40%，且最大延迟降低三倍的传输效果。  
纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。  
连时钟都需要外部传递进来，内部不会有任何一次系统调用。

整个协议只有 ikcp\.h, ikcp\.c两个源文件，可以方便的集成到用户自己的协议栈中。  
也许你实现了一个P2P，或者某个基于 UDP的协议，而缺乏一套完善的ARQ可靠协议实现，那么简单的拷贝这两个文件到现有项目中，稍微编写两行代码，即可使用。

### 2. 技术特性

TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。  
而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以10%\-20%带宽浪费的代价换取了比 TCP快30%\-40%的传输速度。  
TCP信道是一条流速很慢，但每秒流量很大的大运河，而KCP是水流湍急的小激流。  
KCP有正常模式和快速模式两种，通过以下策略达到提高流速的结果。

#### 2.1 RTO翻倍 vs 不翻倍

TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，十分恐怖，而KCP启动快速模式后不x2，只是x1.5（实验证明1.5这个值相对比较好），提高了传输速度。

#### 2.2 选择性重传 vs 全部重传

TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。

#### 2.3 快速重传

发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。

#### 2.4 延迟ACK vs 非延迟ACK

TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大 RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟发送可以调节。

#### 2.5 UNA vs ACK\+UNA

ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而 KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。

#### 2.6 非退让流控

KCP正常模式同TCP一样使用公平退让法则，即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。  
但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率之代价，换取了开着BT都能流畅传输的效果。

### 3. KCP Header

KCP协议头总长度24字节。

- conv:(4 bytes)会话编号，相同会话ID的信息才能互通
- cmd:(1 byte)分片类型，用于区分不同的分片类型。IKCP\_CMD\_PUSH数据分片 ICKP\_CMD\_ACK:ack分片 IKCP\_CMD\_WASK:请求告知窗口大小 IKCP\_CMD\_WINS:告知窗口大小
- frg:(1 byte)分片编号，编号一次递减，0号分片代表最后一个分片
- wnd:(2 bytes)发送方剩余接收窗口大小（recv_window - recv_queue），发送方的发送窗口不能超过接收方给出的数值
- ts:(4 bytes)发送数据包时的时间戳
- sn:(4 bytes)分片segment的序号,按1累加递增
- una:(4 bytes)待接收消息序号
- len:(4 bytes)消息长度

### 4. 未完待续
